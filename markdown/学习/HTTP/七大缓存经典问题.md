# 七大缓存经典问题

## 1：缓存失效

### 原因分析

在写缓存时，我们一般会根据业务的访问特点，给每种业务数据预置一个过期时间，在写缓存时把这个过期时间带上，让缓存在这个固定的过期时间后被淘汰。一般情况下，因为缓存数据是逐步写入的，所以也是逐步过期被淘汰的。但在某些场景，一大批数据会被系统主动或被动从DB 批量加载，然后写入缓存。这些数据写入缓存时，由于使用相同的过期时间，在经过这个过期时间后，这批数据就会同时到期，从而被缓存淘汰。此时，对这批数据的所有请求，就都会出现缓存失效的问题，从而都穿透到 DB，直接查询 DB，DB 由于查询量太大，就很容易压力大增，请求变慢。

### 解决方案

对于批量 key 缓存失效的问题，原因既然是预置的固定时间导致的问题，那解决方案也从这里入手。开发人员在设计缓存过期时间的时候，可以使用公式：`过期时间 = base 时间 + 随机时间` 。即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间，让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力。



## 2：缓存穿透

### 原因分析

缓存穿透存在的原因：我们在系统设计时，更多考虑的是正常访问路径，对特殊访问路径、异常访问路径考虑相对欠缺。但是如果用户访问的是一个不存在的 key，查 DB 返回空（NULL），那就不会把这个空写回 cache。那以后不管查询多少次这个不存在的 key，都会缓存未命中（cache miss），都会查询 DB。整个系统就会退化成一个 “前端+ DB” 的系统，由于 DB 的吞吐只在 cache 的 1%~2% 以下，如果有特殊访客，大量访问这些不存在的 key，就会导致系统的性能严重退化，影响正常用户的访问。

### 解决方案

1：查询这些不存在的数据时，第一次查 DB，虽然没查到结果返回 NULL，仍然记录这个 key 到缓存，只是这个 key 对应的 value 是一个特殊设置的值，但是如果特殊访客持续访问大量不存在的 key，这些 key 即便只存在一个简单的默认值，也会占用大量的缓存空间，导致正常 key 的命中率下降。**所以进一步的改进措施是**：对这些不存在的 key 值存较短的时间，让它们尽快过期；或者将这些不存在的 key 存在一个独立的公共缓存，从缓存查找时，先查正常的缓存组件，如果缓存未命中（miss），则查一下公共的非法 key 的缓存，如果后者命中，直接返回，否则穿透 DB，如果查出来是空，则回种到非法 key 缓存，否则回种到正常缓存。

2：构建一个缓存过滤器 BloomFilter（布隆过滤器），记录全量数据，这样访问数据时，可以直接通过 BloomFilter（布隆过滤器） 判断这个 key 是否存在，如果不存在就直接返回即可，根本无需查缓存和 DB。但是 BloomFilter（布隆过滤器） 要缓存全量的 key，这就要求全量的 key 数量不大，10亿 条数据以内最佳，因为10亿条数据大概需要占用 1.2GB 的内存。也可以用 BloomFilter（布隆过滤器） 缓存非法 key，每次发现一个 key 是不存在的非法 key，就记录到 BloomFilter（布隆过滤器） 中，这种记录方案，会导致 BloomFilter（布隆过滤器） 存储的 key 持续高速增长，为了避免记录 key 太多而导致误判率增大，需要定期清零处理。

> 什么是 布隆过滤器？
>
> 本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构，特点是高效地插入和查询，可以用来告诉你“某样东西一定不存在或者可能存在”。
>
> 关于 布隆过滤器 的介绍：https://www.jianshu.com/p/2104d11ee0a2



## 3：缓存雪崩

### 原因分析

缓存雪崩按照缓存是否 rehash （即是否漂移）分两种情况：

1. 缓存不支持 reshash 导致的系统雪崩不可用
2. 缓存支持 rehash 导致的缓存雪崩不可用

在上述两种情况下，缓存不进行 rehash 时产生的雪崩，一般是由于较多缓存节点不可用，请求穿透导致 DB 也过载不可用，最终整个系统雪崩不可用的。而缓存支持 rehash 时产生的雪崩，则大多跟流量洪峰有关，流量洪峰到达，引发部分缓存节点过载 Crash，然后因 rehash 扩散到其他缓存节点，最终整个缓存体系异常。

### 解决方案

1. 对业务 DB 的访问增加读写开关，当发现 DB 请求变慢、阻塞、慢请求超过阈值时，就会关闭读开关，部分或所有读 DB 的请求进行 failfast 立即返回，待 DB 恢复后再代开读开关
2. 对缓存增加多个副本，缓存异常或请求 miss 后，再读取其他缓存副本，而且多个缓存副本尽量部署在不同机器，从而保证在任何情况下，缓存系统都会正常对外提供服务
3. 对缓存体系进行实时监控，当请求访问的慢速比超过阈值时，及时报警，通过机器替换、服务替换进行及时恢复；也可以通各种自动故障转义策略，自动关闭异常接口、停止边缘服务、停止部分非核心功能措施，确保在极端场景下，核心功能的正常运行。



## 4：数据不一致

### 原因分析

不一致的问题大多跟缓存更新异常有关。比如更新 DB 后，写缓存失败，从而导致缓存中存在老数据。另外，如果系统采用一致性 Hash 分布，同时采用 rehash 自动漂移策略，在节点多次上下线之后，也会产生脏数据。缓存有多个副本时，更新某个副本失败，也会导致这个副本的数据是老数据。

### 解决方案

1. cache 更新失败后，可以进行重试，如果重试失败，则将失败的 key 写入队列机服务，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性
2. 缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性
3. 不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生

> 缓存分层策略：类似于swoole 里面的 table



## 5：数据并发竞争

### 原因分析

数据并发竞争，主要是由于多个进程/线程中，有大量并发请求获取相同的数据，而这个数据 key 因为正好过期、被剔除等各种原因在缓存中不存在，这些进程/线程之间没有任何协调，然后一起并发查询 DB，请求那个相同的 key，最终导致 DB 压力大增。

### 解决方案

1. 全局锁🔐：即当缓存请求 miss 后，先尝试加全局锁🔐，只有加全局锁成功的线程，才可以到 DB  去加载数据。其他 进程/线程 在读取缓存 miss 时，如果发现这个 key 有全局锁锁，就进行等待，待之前的线程将数据从 DB 回种到缓存后，再从缓存获取
2. 对缓存数据保持多个备份，即便其中一个备份中的数据过去或被剔除了，还可以访问其他备份，从而减少数据并发竞争的情况



## 6：Hot key

### 原因分析

Hot Key 引发缓存系统异常，主要是因为数十万、数百万的用户同时请求同一个 key，流量集中打在一个缓存节点机器，这个缓存机器很容易被打到物理网卡、带宽、CPU 的极限，从而导致缓存访问变慢、卡顿。

### 解决方案

1. 找到对应的热点 key，将这些热 key进行分散处理，比如一个热 key名字叫做 hotkey，可以被分散为 hotkey#1、hotkey#2、hotkey#3，……. hotkey#n，这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就把热 key 的请求打散，避免一个缓存节点过载
2. 也可以 key 的名字不变，对缓存提前进行多副本+多级结合的缓存架构设计。再次，如果热 key 较多，还可以通过监控体系对缓存的 SLA 实时监控，通过快速扩容来减少热 key 的冲击。最后，业务端还可以使用本地缓存，将这些热 key 记录在本地缓存，来减少对远程缓存的冲击



## 7：Big Key

#### 原因分析

造成这个大 key 慢查询的原因很多。如果这些大 key 占总体数据的比例很小，存Mc，对应的 slab 较少，导致很容易被频繁剔除，对 DB 反复加载，从而导致查询较慢。如果业务中这种大 key 很多，而这种 key 被大量访问，缓存组件的网卡、带宽很容易被打满，也会导致较多的大 key 慢查询。另外，如果大 key 缓存的字段较多，每个字段的变更都会引发对这个缓存数据的变更，同时这些 key 也会被频繁的读取，读写相互影响，也会导致慢查现象。最后，大 key 一旦被缓存淘汰，DB 加载可能需要花费很多时间，这也会导致大 key 查询慢的问题。

### 解决方案

1. 如果数据存在 Mc 中，可以设计一个缓存阈值，当 value 的长度超过阈值，则对内容启用压缩，让 KV 尽量保持小的 size，其次评估大 key 所占的比例，在 Mc 启动之初，就立即预写足够数据的大 key，让 Mc 预先足够多的 trunk size 较大的 slab。确保后面系统运行时，大 key 有足够的空间来进行缓存
2. 如果数据存在 Redis 中，比如业务数据存 set 格式，大 key 对应的 set 结构有几千几万个元素，这种写入 Redis 时会消耗很长的时间，导致 Reids 卡顿。此时，可以扩展新的数据结构，同时让 client 在这些大 key 写缓存之前，进行序列化构建，然后通过 restore 一次性写入
3. 将大 key 分拆为多个 key，尽量减少大 key 的存在。同时由于大 key 一旦穿透到 DB，加载耗时很大，所以可以对这些大 key 进行特殊照顾，比如设置较长的过期时间，比如缓存内部在淘汰 key 时，同等条件下，尽量不淘汰这些大 key。